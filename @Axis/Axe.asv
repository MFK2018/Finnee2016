%% DESCRIPTION
% AXE is the class of the Finnee2016 toolbox that contain all 
% information associated with an axis.
%
%% LIST OF THE CLASS'S PROPERTIES
% *Label*          : Time, intensity, mass...
% *Unit*           : min, m/z...
% *DecimPlace*     : Number of decimal places to use when displaying data
%   related to this axe
% *TIP*            : The total ion profile
% *TIS*            : The total ion spectrum
% *FIS*            : The frequency ion spectrum
% *BIS*            : The base ion spectrum
% *LAST*           : A blank trace
% *ListOfScans*    : All the MS scans that make the dataset
% *Option4crt*     : (Hidden) Options for the creation of this dataset
% *Path2Dat*       : (Hidden) A list of all the dat files 
% *AxeX*           : Information about the time axis
% *AxeY*           : Information about the m/z axis
% *AxeZ*           : Information about the intensity axis
% *tol4MZ*         : m/z tolerance
%
%% LIST OF THE CLASS'S METHODS:
% *Dataset*        : The constructor method.
% *xpend*          : Allows to expend the m/z axis of a scan to the
%   axe of reference
% *getSpectra*     : Calculate, from this dataset, a MS spectrum made by all
%   the spectra between an interval of time
% *getProfile*     : Calculate, from this dataset, a profile from every
%   ions with a set m/z interval
%
%% COPYRIGHT
% Copyright BSD 3-Clause License Copyright 2016-2017 G. Erny
% (guillaume@fe.up.pt), FEUP, Porto, Portugal
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


classdef Axe
    
    properties
        Label   	 % Time, Intensity or other
        Unit         % min, s...
        DecimPlaces  % Only for display. Number of desimals
        DataStorage  % Define how and where the data are stored
                     %  'None'  : No Data
                     %  'inAxe' : data are within the class
                     %  'inFile': data are stored in an associated binary file
    end
    
    properties (Hidden = true, SetAccess = immutable)
        Precision    % 'inFile' only; Precision in the binary files
        Path2Dat     % 'InFile' only; Address to the file where
                     % the data are stored
        Index        % 'inFile' only; Index to the part of the file of interest
        StoredData   % 'inAxe' only; The data
        
    end
    
    properties (Dependent)
        Data         % The data  
        InfoAxe      % Get back the data of the axe
    end
    
    properties (Dependent, Hidden)
        bz           % Bit sizes, depend on the precision of the binry file    
        fo           % formatting operator from DecimPlaces
    end
    
    methods
        function obj = Axe(infoAxe, data2write)
            % Creator method.
            
            if nargin == 0
                obj.Label        = '';
                obj.Unit         = '';
                obj.DecimPlaces  = 0 ;
                obj.DataStorage  = 'None';
                obj.Precision    = '';
                obj.Path2Dat     = '';
                obj.Index        = [0 0];
                obj.StoredData   = [];
                
            else
                obj.Label       = infoAxe.Label;
                obj.Unit        = infoAxe.Unit;
                obj.DecimPlaces = infoAxe.dp;
                obj.DataStorage = infoAxe.Loc;
                
                % control of data2write
                if nargin == 1
                    obj.DataStorage = 'None';
                elseif isempty(data2write)
                    obj.DataStorage = 'None';
                end
                
                switch lower(obj.DataStorage)
                    case 'none'
                        obj.DataStorage = 'None';
                        obj.Precision   = '';
                        obj.Path2Dat    = '';
                        obj.Index       = [0 0];
                        obj.StoredData  = [];
                        
                    case 'infile'
                        obj.DataStorage = 'inFile';
                        obj.Precision   = infoAxe.Precision;
                        obj.Path2Dat    = infoAxe.Path2Dat;
                        obj.StoredData  = [];
                        
                        %write the data
                        fidWriteDat = fopen(obj.Path2Dat, 'ab');
                        obj.Index(1)= ftell(fidWriteDat);
                        fwrite(fidWriteDat, data2write, obj.Precision);
                        obj.Index(2)= ftell(fidWriteDat);
                        fclose(fidWriteDat);
                        
                    case 'inaxe'
                        obj.DataStorage  = 'inAxe';
                        obj.Precision    = '';
                        obj.Path2Dat     = '';
                        obj.Index        = [0 0];
                        
                        %write the data
                        obj.StoredData   = data2write;
                        
                    otherwise
                        error('Incorrect DataLocation type')
                end
            end
        end
        
        function bz = get.bz(obj)
            % determine number of bite sizes for fread
            
            switch obj.Precision
                case ''
                    bz = 0;
                case {'double', 'int64', 'uint64'}
                    bz = 8;
                case {'single', 'int32', 'uint32'}
                    bz = 4;
                case {'int16', 'uint16'}
                    bz = 2;
                case {'int8', 'uint8'}
                    bz = 1;
            end     
        end
        
        function fo = get.fo(obj)
            % make the adhoc formating opperator 
            if obj.DecimPlaces == 0
                fo = '%i';
            else
                fo = ['%.', num2str(obj.DecimPlaces), 'f'];
            end
        end
        
        function data = get.Data(obj)
            % recover the data depending on the way they are stored 
            
            switch obj.DataStorage
                case'None'
                    data = [];
                    
                case 'inFile'
                    if obj.Index(1) == obj.Index(2)
                        data = [];
                        
                    else
                        n    = obj.bz;
                        prcs = obj.Precision;
                        fidReadDat = fopen(obj.Path2Dat, 'rb');
                        fseek(fidReadDat,  obj.Index(1), 'bof');
                        data = fread(fidReadDat, ...
                            [( obj.Index(2)- obj.Index(1))/n 1], prcs);
                        fclose(fidReadDat);
                    end
                    
                case 'inAxe'
                    data = obj.StoredData;
            end
        end
        
        function infoAxe = get.InfoAxe(obj)
            % Pass backward InfoAxe
            
            infoAxe.Label     = obj.Label;
            infoAxe.Unit      = obj.Unit;
            infoAxe.dp        = obj.DecimPlaces;
            infoAxe.Loc       = obj.DataStorage;
            infoAxe.Precision = obj.Precision;
            infoAxe.Path2Dat  = obj.Path2Dat;
            
        end
        
        function  obj = set.Label(obj, value)
            % standardised the labels string (need to be improved)
            
            switch lower(value)
                case {'time'}
                    obj.Label = 'Time';
                    
                case {'mass'}
                    obj.Label = 'Mass';
                    
                case {'intensity'}
                    obj.Label = 'Intensity';
            end
        end
        
        function  obj = set.Unit(obj, value)
            % standardised the units string (need to be improved)

            switch lower(value)
                case {'minutes', 'min', 'minute'}
                    obj.Unit = 'min';
                    
                case {'secondes', 'sec', 's'}
                    obj.Unit = 's';
                    
                case{'number of detector counts', 'counts'}
                    obj.Unit = 'counts';
                    
                case{'m/z'}
                    obj.Unit = 'm/z';
                    
                otherwise
                    obj.Unit = '';
                    
            end
        end
    end
end
    
